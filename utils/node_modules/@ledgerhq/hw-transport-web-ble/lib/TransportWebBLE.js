"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _open = function () {
  var _ref4 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(deviceOrId, needsReconnect) {
    var device, bluetooth, _ref5, _ref6, service, infos, deviceModel, writeUuid, notifyUuid, _ref7, _ref8, writeC, notifyC, notifyObservable, notif, transport, onDisconnect, beforeMTUTime, afterMTUTime;

    return regeneratorRuntime.wrap(function _callee2$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            device = void 0;

            if (!(typeof deviceOrId === "string")) {
              _context2.next = 11;
              break;
            }

            if (!transportsCache[deviceOrId]) {
              _context2.next = 5;
              break;
            }

            (0, _logs.log)("ble-verbose", "Transport in cache, using that.");
            return _context2.abrupt("return", transportsCache[deviceOrId]);

          case 5:
            bluetooth = requiresBluetooth();

            // TODO instead we should "query" the device by its ID

            _context2.next = 8;
            return bluetooth.requestDevice(requestDeviceParam());

          case 8:
            device = _context2.sent;
            _context2.next = 12;
            break;

          case 11:
            device = deviceOrId;

          case 12:
            if (device.gatt.connected) {
              _context2.next = 16;
              break;
            }

            (0, _logs.log)("ble-verbose", "not connected. connecting...");
            _context2.next = 16;
            return device.gatt.connect();

          case 16:
            _context2.next = 18;
            return retrieveService(device);

          case 18:
            _ref5 = _context2.sent;
            _ref6 = _slicedToArray(_ref5, 2);
            service = _ref6[0];
            infos = _ref6[1];
            deviceModel = infos.deviceModel, writeUuid = infos.writeUuid, notifyUuid = infos.notifyUuid;
            _context2.next = 25;
            return Promise.all([service.getCharacteristic(writeUuid), service.getCharacteristic(notifyUuid)]);

          case 25:
            _ref7 = _context2.sent;
            _ref8 = _slicedToArray(_ref7, 2);
            writeC = _ref8[0];
            notifyC = _ref8[1];
            notifyObservable = (0, _monitorCharacteristic.monitorCharacteristic)(notifyC).pipe((0, _operators.tap)(function (value) {
              (0, _logs.log)("ble-frame", "<= " + value.toString("hex"));
            }), (0, _operators.share)());
            notif = notifyObservable.subscribe();
            transport = new BluetoothTransport(device, writeC, notifyObservable, deviceModel);

            if (device.gatt.connected) {
              _context2.next = 34;
              break;
            }

            throw new _errors.DisconnectedDevice();

          case 34:

            transportsCache[transport.id] = transport;

            onDisconnect = function onDisconnect(e) {
              console.log("onDisconnect!", e);
              delete transportsCache[transport.id];
              transport.notYetDisconnected = false;
              notif.unsubscribe();
              device.removeEventListener("gattserverdisconnected", onDisconnect);
              (0, _logs.log)("ble-verbose", "BleTransport(" + transport.id + ") disconnected");
              transport.emit("disconnect", e);
            };

            device.addEventListener("gattserverdisconnected", onDisconnect);

            beforeMTUTime = Date.now();
            _context2.prev = 38;
            _context2.next = 41;
            return transport.inferMTU();

          case 41:
            _context2.prev = 41;
            afterMTUTime = Date.now();

            // workaround for #279: we need to open() again if we come the first time here,
            // to make sure we do a disconnect() after the first pairing time
            // because of a firmware bug

            if (afterMTUTime - beforeMTUTime < 1000) {
              needsReconnect = false; // (optim) there is likely no new pairing done because mtu answer was fast.
            }

            if (!needsReconnect) {
              _context2.next = 49;
              break;
            }

            _context2.next = 47;
            return device.gatt.disconnect();

          case 47:
            _context2.next = 49;
            return new Promise(function (s) {
              return setTimeout(s, 4000);
            });

          case 49:
            return _context2.finish(41);

          case 50:
            if (!needsReconnect) {
              _context2.next = 52;
              break;
            }

            return _context2.abrupt("return", _open(device, false));

          case 52:
            return _context2.abrupt("return", transport);

          case 53:
          case "end":
            return _context2.stop();
        }
      }
    }, _callee2, this, [[38,, 41, 50]]);
  }));

  return function _open(_x2, _x3) {
    return _ref4.apply(this, arguments);
  };
}();

/**
 * react-native bluetooth BLE implementation
 * @example
 * import BluetoothTransport from "@ledgerhq/hw-transport-web-ble";
 */


var _hwTransport = require("@ledgerhq/hw-transport");

var _hwTransport2 = _interopRequireDefault(_hwTransport);

var _errors = require("@ledgerhq/errors");

var _devices = require("@ledgerhq/devices");

var _sendAPDU = require("@ledgerhq/devices/lib/ble/sendAPDU");

var _receiveAPDU = require("@ledgerhq/devices/lib/ble/receiveAPDU");

var _logs = require("@ledgerhq/logs");

var _rxjs = require("rxjs");

var _operators = require("rxjs/operators");

var _monitorCharacteristic = require("./monitorCharacteristic");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }
/* eslint-disable prefer-template */

var requiresBluetooth = function requiresBluetooth() {
  // $FlowFixMe
  var _navigator = navigator,
      bluetooth = _navigator.bluetooth;

  if (typeof bluetooth === "undefined") {
    throw new Error("web bluetooth not supported");
  }
  return bluetooth;
};

var availability = function availability() {
  return _rxjs.Observable.create(function (observer) {
    var bluetooth = requiresBluetooth();
    var onAvailabilityChanged = function onAvailabilityChanged(e) {
      observer.next(e.value);
    };
    bluetooth.addEventListener("availabilitychanged", onAvailabilityChanged);
    var unsubscribed = false;
    bluetooth.getAvailability().then(function (available) {
      if (!unsubscribed) {
        observer.next(available);
      }
    });
    return function () {
      unsubscribed = true;
      bluetooth.removeEventListener("availabilitychanged", onAvailabilityChanged);
    };
  });
};

var transportsCache = {};

var requestDeviceParam = function requestDeviceParam() {
  return {
    filters: (0, _devices.getBluetoothServiceUuids)().map(function (uuid) {
      return {
        services: [uuid]
      };
    })
  };
};

var retrieveService = function () {
  var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(device) {
    var _ref2, _ref3, service, infos;

    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (device.gatt) {
              _context.next = 2;
              break;
            }

            throw new Error("bluetooth gatt not found");

          case 2:
            _context.next = 4;
            return device.gatt.getPrimaryServices();

          case 4:
            _ref2 = _context.sent;
            _ref3 = _slicedToArray(_ref2, 1);
            service = _ref3[0];

            if (service) {
              _context.next = 9;
              break;
            }

            throw new Error("bluetooth service not found");

          case 9:
            infos = (0, _devices.getInfosForServiceUuid)(service.uuid);

            if (infos) {
              _context.next = 12;
              break;
            }

            throw new Error("bluetooth service infos not found");

          case 12:
            return _context.abrupt("return", [service, infos]);

          case 13:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, undefined);
  }));

  return function retrieveService(_x) {
    return _ref.apply(this, arguments);
  };
}();

var BluetoothTransport = function (_Transport) {
  _inherits(BluetoothTransport, _Transport);

  _createClass(BluetoothTransport, null, [{
    key: "listen",


    /**
     * Scan for Ledger Bluetooth devices.
     * On this web implementation, it only emits ONE device, the one that was selected in the UI (if any).
     */


    /**
     * observe event with { available: bool, type: string }
     * (available is generic, type is specific)
     * an event is emit once and then each time it changes
     */
    value: function listen(observer) {
      var _this2 = this;

      (0, _logs.log)("ble-verbose", "listen...");
      var unsubscribed = void 0;

      var bluetooth = requiresBluetooth();

      bluetooth.requestDevice(requestDeviceParam()).then(function () {
        var _ref9 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee3(device) {
          return regeneratorRuntime.wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  if (!unsubscribed) {
                    observer.next({
                      type: "add",
                      descriptor: device
                    });
                    observer.complete();
                  }

                case 1:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3, _this2);
        }));

        return function (_x4) {
          return _ref9.apply(this, arguments);
        };
      }(), function (error) {
        observer.error(new _errors.TransportOpenUserCancelled(error.message));
      });
      function unsubscribe() {
        unsubscribed = true;
      }
      return { unsubscribe: unsubscribe };
    }

    /**
     * open a bluetooth device.
     */

  }, {
    key: "open",
    value: function () {
      var _ref10 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee4(deviceOrId) {
        return regeneratorRuntime.wrap(function _callee4$(_context4) {
          while (1) {
            switch (_context4.prev = _context4.next) {
              case 0:
                return _context4.abrupt("return", _open(deviceOrId, true));

              case 1:
              case "end":
                return _context4.stop();
            }
          }
        }, _callee4, this);
      }));

      function open(_x5) {
        return _ref10.apply(this, arguments);
      }

      return open;
    }()

    /**
     * globally disconnect a bluetooth device by its id.
     */

  }]);

  function BluetoothTransport(device, writeCharacteristic, notifyObservable, deviceModel) {
    var _this3 = this;

    _classCallCheck(this, BluetoothTransport);

    var _this = _possibleConstructorReturn(this, (BluetoothTransport.__proto__ || Object.getPrototypeOf(BluetoothTransport)).call(this));

    _this.mtuSize = 20;
    _this.notYetDisconnected = true;

    _this.exchange = function (apdu) {
      return _this.exchangeAtomicImpl(_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee5() {
        var msgIn, data, msgOut;
        return regeneratorRuntime.wrap(function _callee5$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
                _context5.prev = 0;
                msgIn = apdu.toString("hex");

                (0, _logs.log)("apdu", "=> " + msgIn);

                _context5.next = 5;
                return (0, _rxjs.merge)(_this.notifyObservable.pipe(_receiveAPDU.receiveAPDU), (0, _sendAPDU.sendAPDU)(_this.write, apdu, _this.mtuSize)).toPromise();

              case 5:
                data = _context5.sent;
                msgOut = data.toString("hex");

                (0, _logs.log)("apdu", "<= " + msgOut);

                return _context5.abrupt("return", data);

              case 11:
                _context5.prev = 11;
                _context5.t0 = _context5["catch"](0);

                (0, _logs.log)("ble-error", "exchange got " + String(_context5.t0));
                if (_this.notYetDisconnected) {
                  // in such case we will always disconnect because something is bad.
                  _this.device.gatt.disconnect();
                }
                throw _context5.t0;

              case 16:
              case "end":
                return _context5.stop();
            }
          }
        }, _callee5, _this3, [[0, 11]]);
      })));
    };

    _this.write = function () {
      var _ref12 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee6(buffer) {
        return regeneratorRuntime.wrap(function _callee6$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                (0, _logs.log)("ble-frame", "=> " + buffer.toString("hex"));
                _context6.next = 3;
                return _this.writeCharacteristic.writeValue(buffer);

              case 3:
              case "end":
                return _context6.stop();
            }
          }
        }, _callee6, _this3);
      }));

      return function (_x6) {
        return _ref12.apply(this, arguments);
      };
    }();

    _this.id = device.id;
    _this.device = device;
    _this.writeCharacteristic = writeCharacteristic;
    _this.notifyObservable = notifyObservable;
    _this.deviceModel = deviceModel;

    (0, _logs.log)("ble-verbose", "BleTransport(" + String(_this.id) + ") new instance");
    return _this;
  }

  _createClass(BluetoothTransport, [{
    key: "inferMTU",
    value: function () {
      var _ref13 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee8() {
        var _this4 = this;

        var mtu, mtuSize;
        return regeneratorRuntime.wrap(function _callee8$(_context8) {
          while (1) {
            switch (_context8.prev = _context8.next) {
              case 0:
                mtu = 23;
                _context8.next = 3;
                return this.exchangeAtomicImpl(_asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee7() {
                  return regeneratorRuntime.wrap(function _callee7$(_context7) {
                    while (1) {
                      switch (_context7.prev = _context7.next) {
                        case 0:
                          _context7.prev = 0;
                          _context7.next = 3;
                          return (0, _rxjs.merge)(_this4.notifyObservable.pipe((0, _operators.first)(function (buffer) {
                            return buffer.readUInt8(0) === 0x08;
                          }), (0, _operators.map)(function (buffer) {
                            return buffer.readUInt8(5);
                          })), (0, _rxjs.defer)(function () {
                            return (0, _rxjs.from)(_this4.write(Buffer.from([0x08, 0, 0, 0, 0])));
                          }).pipe((0, _operators.ignoreElements)())).toPromise();

                        case 3:
                          _context7.t0 = _context7.sent;
                          mtu = _context7.t0 + 3;
                          _context7.next = 12;
                          break;

                        case 7:
                          _context7.prev = 7;
                          _context7.t1 = _context7["catch"](0);

                          (0, _logs.log)("ble-error", "inferMTU got " + String(_context7.t1));
                          _this4.device.gatt.disconnect();
                          throw _context7.t1;

                        case 12:
                        case "end":
                          return _context7.stop();
                      }
                    }
                  }, _callee7, _this4, [[0, 7]]);
                })));

              case 3:

                if (mtu > 23) {
                  mtuSize = mtu - 3;

                  (0, _logs.log)("ble-verbose", "BleTransport(" + String(this.id) + ") mtu set to " + String(mtuSize));
                  this.mtuSize = mtuSize;
                }

                return _context8.abrupt("return", this.mtuSize);

              case 5:
              case "end":
                return _context8.stop();
            }
          }
        }, _callee8, this);
      }));

      function inferMTU() {
        return _ref13.apply(this, arguments);
      }

      return inferMTU;
    }()

    /**
     * Exchange with the device using APDU protocol.
     * @param apdu
     * @returns a promise of apdu response
     */

  }, {
    key: "setScrambleKey",
    value: function setScrambleKey() {}
  }, {
    key: "close",
    value: function () {
      var _ref15 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee9() {
        return regeneratorRuntime.wrap(function _callee9$(_context9) {
          while (1) {
            switch (_context9.prev = _context9.next) {
              case 0:
                if (!this.exchangeBusyPromise) {
                  _context9.next = 3;
                  break;
                }

                _context9.next = 3;
                return this.exchangeBusyPromise;

              case 3:
              case "end":
                return _context9.stop();
            }
          }
        }, _callee9, this);
      }));

      function close() {
        return _ref15.apply(this, arguments);
      }

      return close;
    }()
  }]);

  return BluetoothTransport;
}(_hwTransport2.default);

BluetoothTransport.isSupported = function () {
  return Promise.resolve().then(requiresBluetooth).then(function () {
    return true;
  }, function () {
    return false;
  });
};

BluetoothTransport.observeAvailability = function (observer) {
  return availability.subscribe(observer);
};

BluetoothTransport.list = function () {
  return Promise.resolve([]);
};

BluetoothTransport.disconnect = function () {
  var _ref16 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee10(id) {
    var transport;
    return regeneratorRuntime.wrap(function _callee10$(_context10) {
      while (1) {
        switch (_context10.prev = _context10.next) {
          case 0:
            (0, _logs.log)("ble-verbose", "user disconnect(" + id + ")");
            transport = transportsCache[id];

            if (transport) {
              transport.device.gatt.disconnect();
            }

          case 3:
          case "end":
            return _context10.stop();
        }
      }
    }, _callee10, undefined);
  }));

  return function (_x7) {
    return _ref16.apply(this, arguments);
  };
}();

exports.default = BluetoothTransport;
//# sourceMappingURL=TransportWebBLE.js.map